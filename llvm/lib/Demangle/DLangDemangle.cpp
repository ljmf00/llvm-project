//===--- DLangDemangle.cpp -------------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
///
/// \file
/// This file defines a demangler for D programming language as specified in the
/// ABI specification, available at:
/// https://dlang.org/spec/abi.html#name_mangling
///
//===----------------------------------------------------------------------===//
//
// Ported from libiberty library.
//
//===----------------------------------------------------------------------===//

#include "llvm/Demangle/Demangle.h"
#include "llvm/Demangle/MicrosoftDemangleNodes.h"

#include <cassert>
#include <cctype>
#include <cstdlib>
#include <cstring>
#include <limits.h>

using namespace llvm;

namespace {

/// A mini string-handling class for output strings generated by D demangler
///
/// \note Beware these aren't required to be '\0' terminated
struct OutputString {

  /// pointer to start of string
  char *Buffer;
  /// pointer after last character
  char *Ptr;
  /// pointer after end of allocated space
  char *EndPtr;

public:
  /// Constructs a new output string
  OutputString();

  /// Free resources previously allocated to the Buffer
  void free();

  /// Get the current length of the string
  int getLength();

  /// Set a given new length to the string
  ///
  /// \param Size new length
  void setLength(int Size);

  /// Append a given single char to the string
  ///
  /// \param C char to append
  void append(char C);

  /// Append a given input to the string
  ///
  /// \param Str input string to append
  void append(const char *Str);

  /// Append a given input with a specific length to the string
  ///
  /// \param Str input string to append
  /// \param Size length to append from the given input string
  void append(const char *Str, size_t Size);

  /// Prepend a given input to the string
  ///
  /// \param Str input string to prepend
  void prepend(const char *Str);

  /// Prepend a given input with a specific length to the string
  ///
  /// \param Str input string to prepend
  /// \param Size length to prepend from the given input string
  void prepend(const char *Str, size_t Size);

private:
  /// Allocate more needed space to the Buffer
  ///
  /// \param Size size of the space needed
  void need(size_t Size);
};

/// Demangle information structure
struct Demangler {
  /// Initialize the information structure we use to pass around information
  ///
  /// \param Mangled String to demangle
  Demangler(const char *Mangled);

  /// Extract and demangle the mangled symbol and append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#name_mangling
  /// \see https://dlang.org/spec/abi.html#MangledName
  const char *parseMangle(OutputString *Decl);

private:
  /// Extract and demangle a given mangled symbol and append it to the output
  /// string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#name_mangling
  /// \see https://dlang.org/spec/abi.html#MangledName
  const char *parseMangle(OutputString *Decl, const char *Mangled);

  /// Extract the number from a given string
  ///
  /// \param Mangled string to extract the number
  /// \param Ret assigned result value
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \note A result larger than UINT_MAX is considered a failure
  ///
  /// \see https://dlang.org/spec/abi.html#Number
  const char *decodeNumber(const char *Mangled, unsigned long *Ret);

  /// Extract the hex-digit from a given string
  ///
  /// \param Mangled string to extract the hex-digit
  /// \param Ret assigned result value
  ///
  /// \return the remaining string on success or nullptr on failure.
  ///
  /// \see https://dlang.org/spec/abi.html#HexDigits
  const char *decodeHexdigit(const char *Mangled, char *Ret);

  /// Extract the back reference position from a given string
  ///
  /// \param Mangled string to extract the back reference position
  /// \param Ret assigned result value
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \note a result <= 0 is a failure
  ///
  /// \see https://dlang.org/spec/abi.html#back_ref
  /// \see https://dlang.org/spec/abi.html#NumberBackRef
  const char *decodeBackrefPos(const char *Mangled, long *Ret);

  /// Extract the symbol pointed by the back reference form a given string
  ///
  /// \param Mangled string to extract the back reference position
  /// \param Ret assigned result value
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#back_ref
  const char *decodeBackref(const char *Mangled, const char **Ret);

  /// Extract and demangle backreferenced symbol from a given mangled symbol
  /// and append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#back_ref
  /// \see https://dlang.org/spec/abi.html#IdentifierBackRef
  const char *parseSymbolBackref(OutputString *Decl, const char *Mangled);

  /// Extract and demangle backreferenced type from a given mangled symbol
  /// and append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  /// \param IsFunction whether the backreferenced type is expected to be a
  ///                   function
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#back_ref
  /// \see https://dlang.org/spec/abi.html#TypeBackRef
  const char *parseTypeBackref(OutputString *Decl, const char *Mangled,
                               bool IsFunction);

  /// Check whether it is a function calling convention
  ///
  /// \param Mangled string to extract the function calling convention
  ///
  /// \return true on success, false otherwise
  ///
  /// \see https://dlang.org/spec/abi.html#CallConvention
  /// \see https://dlang.org/spec/abi.html#function_calling_conventions
  bool isCallConvention(const char *Mangled);

  /// Extract and demangle calling convention from a given mangled symbol and
  /// append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#CallConvention
  /// \see https://dlang.org/spec/abi.html#function_calling_conventions
  const char *parseCallConvention(OutputString *Decl, const char *Mangled);

  /// Check whether it is the beginning of a symbol name
  ///
  /// \param Mangled string to extract the symbol name
  ///
  /// \return true on success, false otherwise
  ///
  /// \see https://dlang.org/spec/abi.html#SymbolName
  bool isSymbolName(const char *Mangled);

  /// Extract and demangle an identifier from a given mangled symbol append it
  /// to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#SymbolName
  const char *parseIdentifier(OutputString *Decl, const char *Mangled);

  /// Extract and demangle the plain identifier from a given mangled symbol and
  /// prepend/append it to the output string, with a special treatment for some
  /// magic compiler generated symbols.
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  /// \param Len length of the mangled symbol name
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#LName
  const char *parseLName(OutputString *Decl, const char *Mangled,
                         unsigned long Len);

  /// Extract and demangle the qualified symbol from a given mangled symbol
  /// append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  /// \param SuffixModifiers true if we are printing the modifiers after the
  ///                        symbol, false otherwise
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#QualifiedName
  const char *parseQualified(OutputString *Decl, const char *Mangled,
                             bool SuffixModifiers);

  /// Extract and demangle the type modifiers from a given mangled symbol
  /// append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#TypeModifiers
  const char *parseTypeModifiers(OutputString *Decl, const char *Mangled);

  /// Extract and demangle the D function attributes from a given mangled
  /// symbol append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#FuncAttr
  const char *parseAttributes(OutputString *Decl, const char *Mangled);

  /// Extract and demangle the function type from a given mangled symbol
  /// without the return type and append it to the arguments, calling
  /// convention and attribute output strings, respectively.
  ///
  /// \param Args output buffer to write the demangled arguments
  /// \param Call output buffer to write the demangled calling convention
  /// \param Attr output buffer to write the demangled attributes
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \note Any of the output strings can be nullptr to throw the information
  ///       away.
  ///
  /// \see https://dlang.org/spec/abi.html#TypeFunctionNoReturn
  const char *parseFunctionTypeNoreturn(OutputString *Args, OutputString *Call,
                                        OutputString *Attr,
                                        const char *Mangled);

  /// Extract and demangle the function type from a given mangled symbol
  /// append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#TypeFunction
  const char *parseFunctionType(OutputString *Decl, const char *Mangled);

  /// Extract and demangle the function arguments list from a given mangled
  /// symbol append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#Parameters
  const char *parseFunctionArgs(OutputString *Decl, const char *Mangled);

  /// Extract and demangle a type from a given mangled symbol append it to
  /// the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#Type
  const char *parseType(OutputString *Decl, const char *Mangled);

  /// Extract and demangle an integer value from a given mangled symbol append
  /// it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  /// \param Type mangled type character in which the type should be
  ///             represented as
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#Value
  const char *parseInteger(OutputString *Decl, const char *Mangled, char Type);

  /// Extract and demangle a floating-point value from a given mangled symbol
  /// append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#Value
  const char *parseReal(OutputString *Decl, const char *Mangled);

  /// Extract and demangle a string value from a given mangled symbol append it
  /// to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#Value
  const char *parseString(OutputString *Decl, const char *Mangled);

  /// Extract and demangle an array literal value from a given mangled symbol
  /// append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#Value
  const char *parseArrayLiteral(OutputString *Decl, const char *Mangled);

  /// Extract and demangle an associative array value from a given mangled
  /// symbol append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#Value
  const char *parseAssocArray(OutputString *Decl, const char *Mangled);

  /// Extract and demangle an struct literal value from a given mangled symbol
  /// append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  /// \param Name demangled symbol name of the struct literal
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#Value
  const char *parseStructLiteral(OutputString *Decl, const char *Mangled,
                                 const char *Name);

  /// Extract and demangle any value from a given mangled symbol append it to
  /// the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  /// \param Name demangled symbol name of the type, if needed
  /// \param Type mangled type character in which the type should be
  ///             represented as, if needed
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#Value
  const char *parseValue(OutputString *Decl, const char *Mangled,
                         const char *Name, char Type);

  /// Extract and demangle a tuple value from a given mangled symbol append it
  /// to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#TypeTuple
  const char *parseTuple(OutputString *Decl, const char *Mangled);

  /// Extract and demangle the template symbol parameter from a given mangled
  /// symbol append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#TemplateArgX
  const char *parseTemplateSymbolParameter(OutputString *Decl,
                                           const char *Mangled);

  /// Extract and demangle the template arguments list from a given mangled
  /// symbol append it to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#TemplateArgs
  const char *parseTemplateArgs(OutputString *Decl, const char *Mangled);

  /// Extract and demangle a template from a given mangled symbol and append it
  /// to the output string
  ///
  /// \param Decl output buffer to write the demangled name
  /// \param Mangled mangled symbol to be demangled
  /// \param Len expected characters length (default to -1 if unknown length)
  ///
  /// \return the remaining string on success or nullptr on failure
  ///
  /// \see https://dlang.org/spec/abi.html#TemplateInstanceName
  const char *parseTemplate(OutputString *Decl, const char *Mangled,
                            unsigned long Len = -1);

  /// The string we are demangling.
  const char *Str;
  /// The index of the last back reference.
  int LastBackref;
};

} // namespace

void OutputString::need(size_t Size) {
  size_t Temp;

  if (Buffer == nullptr) {
    if (Size < 32) {
      Size = 32;
    }
    Ptr = Buffer = static_cast<char *>(std::malloc(Size));
    EndPtr = Buffer + Size;
  } else if (static_cast<size_t>(EndPtr - Ptr) < Size) {
    Temp = Ptr - Buffer;
    Size += Temp;
    Size *= 2;
    Buffer = static_cast<char *>(std::realloc(Buffer, Size));
    Ptr = Buffer + Temp;
    EndPtr = Buffer + Size;
  }
}

OutputString::OutputString() : Buffer(nullptr), Ptr(nullptr), EndPtr(nullptr) {}

void OutputString::free() {
  if (Buffer != nullptr) {
    std::free(Buffer);
    Buffer = Ptr = EndPtr = nullptr;
  }
}

int OutputString::getLength() {
  if (Ptr == Buffer) {
    return 0;
  }
  return Ptr - Buffer;
}

void OutputString::setLength(int Size) {
  if (Size - getLength() < 0) {
    Ptr = Buffer + Size;
  }
}

void OutputString::append(char C) {
  need(1);
  *Ptr = C;
  Ptr++;
}

void OutputString::append(const char *Str) { append(Str, strlen(Str)); }

void OutputString::append(const char *Str, size_t Size) {
  if (Size != 0) {
    need(Size);
    std::memcpy(Ptr, Str, Size);
    Ptr += Size;
  }
}

void OutputString::prepend(const char *Str) {
  if (Str != nullptr && *Str != '\0') {
    prepend(Str, strlen(Str));
  }
}

void OutputString::prepend(const char *Str, size_t Size) {
  char *TempBuffer;

  if (Size != 0) {
    need(Size);
    for (TempBuffer = Ptr - 1; TempBuffer >= Buffer; TempBuffer--) {
      TempBuffer[Size] = TempBuffer[0];
    }
    std::memcpy(Buffer, Str, Size);
    Ptr += Size;
  }
}

const char *Demangler::decodeNumber(const char *Mangled, unsigned long *Ret) {
  // Return nullptr if trying to extract something that isn't a digit
  if (Mangled == nullptr || !std::isdigit(*Mangled))
    return nullptr;

  unsigned long Val = 0;

  while (std::isdigit(*Mangled)) {
    unsigned long Digit = Mangled[0] - '0';

    // Check for overflow.
    if (Val > (UINT_MAX - Digit) / 10)
      return nullptr;

    Val = Val * 10 + Digit;
    Mangled++;
  }

  if (*Mangled == '\0')
    return nullptr;

  *Ret = Val;
  return Mangled;
}

const char *Demangler::decodeHexdigit(const char *Mangled, char *Ret) {
  char C;

  // Return nullptr if trying to extract something that isn't a hexdigit
  if (Mangled == nullptr || !std::isxdigit(Mangled[0]) ||
      !std::isxdigit(Mangled[1]))
    return nullptr;

  C = Mangled[0];
  if (!std::isdigit(C))
    *Ret = C - (std::isupper(C) ? 'A' : 'a') + 10;
  else
    *Ret = C - '0';

  C = Mangled[1];
  if (!std::isdigit(C))
    *Ret = (*Ret << 4) | (C - (std::isupper(C) ? 'A' : 'a') + 10);
  else
    *Ret = (*Ret << 4) | (C - '0');

  Mangled += 2;

  return Mangled;
}

bool Demangler::isCallConvention(const char *Mangled) {
  switch (*Mangled) {
  case 'F':
  case 'U':
  case 'V':
  case 'W':
  case 'R':
  case 'Y':
    return true;

  default:
    return false;
  }
}

const char *Demangler::decodeBackrefPos(const char *Mangled, long *Ret) {
  // Return nullptr if trying to extract something that isn't a digit
  if (Mangled == nullptr || !std::isalpha(*Mangled))
    return nullptr;

  /* Any identifier or non-basic type that has been emitted to the mangled
     symbol before will not be emitted again, but is referenced by a special
     sequence encoding the relative position of the original occurrence in the
     mangled symbol name.
     Numbers in back references are encoded with base 26 by upper case letters
     A-Z for higher digits but lower case letters a-z for the last digit.
        NumberBackRef:
            [a-z]
            [A-Z] NumberBackRef
            ^
   */
  unsigned long Val = 0;

  while (std::isalpha(*Mangled)) {
    // Check for overflow
    if (Val > (ULONG_MAX - 25) / 26)
      break;

    Val *= 26;

    if (Mangled[0] >= 'a' && Mangled[0] <= 'z') {
      Val += Mangled[0] - 'a';
      if ((long)Val <= 0)
        break;
      *Ret = Val;
      return Mangled + 1;
    }

    Val += Mangled[0] - 'A';
    Mangled++;
  }

  return nullptr;
}

const char *Demangler::decodeBackref(const char *Mangled, const char **Ret) {
  *Ret = nullptr;

  if (Mangled == nullptr || *Mangled != 'Q')
    return nullptr;

  // Position of 'Q'
  const char *Qpos = Mangled;
  long RefPos;
  Mangled++;

  Mangled = decodeBackrefPos(Mangled, &RefPos);
  if (Mangled == nullptr)
    return nullptr;

  if (RefPos > Qpos - Str)
    return nullptr;

  /* Set the position of the back reference.  */
  *Ret = Qpos - RefPos;

  return Mangled;
}

const char *Demangler::parseSymbolBackref(OutputString *Decl,
                                          const char *Mangled) {
  /* An identifier back reference always points to a digit 0 to 9.
        IdentifierBackRef:
            Q NumberBackRef
            ^
   */
  const char *Backref;
  unsigned long Len;

  // Get position of the back reference
  Mangled = decodeBackref(Mangled, &Backref);

  // Must point to a simple identifier
  Backref = decodeNumber(Backref, &Len);
  if (Backref == nullptr || strlen(Backref) < Len)
    return nullptr;

  Backref = parseLName(Decl, Backref, Len);
  if (Backref == nullptr)
    return nullptr;

  return Mangled;
}

const char *Demangler::parseTypeBackref(OutputString *Decl, const char *Mangled,
                                        bool IsFunction) {
  /* A type back reference always points to a letter.
        TypeBackRef:
            Q NumberBackRef
            ^
   */
  const char *Backref;

  /* If we appear to be moving backwards through the mangle string, then
     bail as this may be a recursive back reference */
  if (Mangled - Str >= LastBackref)
    return nullptr;

  int SaveRefPos = LastBackref;
  LastBackref = Mangled - Str;

  // Get position of the back reference
  Mangled = decodeBackref(Mangled, &Backref);

  // Must point to a type
  if (IsFunction)
    Backref = parseFunctionType(Decl, Backref);
  else
    Backref = parseType(Decl, Backref);

  LastBackref = SaveRefPos;

  if (Backref == nullptr)
    return nullptr;

  return Mangled;
}

bool Demangler::isSymbolName(const char *Mangled) {
  long Ret;
  const char *Qref = Mangled;

  if (std::isdigit(*Mangled))
    return true;

  if (Mangled[0] == '_' && Mangled[1] == '_' &&
      (Mangled[2] == 'T' || Mangled[2] == 'U'))
    return true;

  if (*Mangled != 'Q')
    return false;

  Mangled = decodeBackrefPos(Mangled + 1, &Ret);
  if (Mangled == nullptr || Ret > Qref - Str)
    return false;

  return std::isdigit(Qref[-Ret]);
}

const char *Demangler::parseCallConvention(OutputString *Decl,
                                           const char *Mangled) {
  if (Mangled == nullptr || *Mangled == '\0')
    return nullptr;

  switch (*Mangled) {
  case 'F': /* (D) */
    Mangled++;
    break;

  case 'U': /* (C) */
    Mangled++;
    Decl->append("extern(C) ");
    break;

  case 'W': /* (Windows) */
    Mangled++;
    Decl->append("extern(Windows) ");
    break;

  case 'V': /* (Pascal) */
    Mangled++;
    Decl->append("extern(Pascal) ");
    break;

  case 'R': /* (C++) */
    Mangled++;
    Decl->append("extern(C++) ");
    break;

  case 'Y': /* (Objective-C) */
    Mangled++;
    Decl->append("extern(Objective-C) ");
    break;

  default:
    return nullptr;
  }

  return Mangled;
}

const char *Demangler::parseTypeModifiers(OutputString *Decl,
                                          const char *Mangled) {
  if (Mangled == nullptr || *Mangled == '\0')
    return nullptr;

  switch (*Mangled) {
  case 'x': /* const */
    Mangled++;
    Decl->append(" const");
    return Mangled;

  case 'y': /* immutable */
    Mangled++;
    Decl->append(" immutable");
    return Mangled;

  case 'O': /* shared */
    Mangled++;
    Decl->append(" shared");
    return parseTypeModifiers(Decl, Mangled);

  case 'N':
    Mangled++;
    if (*Mangled == 'g') /* wild */
    {
      Mangled++;
      Decl->append(" inout");
      return parseTypeModifiers(Decl, Mangled);
    }

    return nullptr;

  default:
    return Mangled;
  }
}

const char *Demangler::parseAttributes(OutputString *Decl,
                                       const char *Mangled) {
  if (Mangled == nullptr || *Mangled == '\0')
    return nullptr;

  while (*Mangled == 'N') {
    Mangled++;
    switch (*Mangled) {
    case 'a': /* pure */
      Mangled++;
      Decl->append("pure ");
      continue;

    case 'b': /* nothrow */
      Mangled++;
      Decl->append("nothrow ");
      continue;

    case 'c': /* ref */
      Mangled++;
      Decl->append("ref ");
      continue;

    case 'd': /* @property */
      Mangled++;
      Decl->append("@property ");
      continue;

    case 'e': /* @trusted */
      Mangled++;
      Decl->append("@trusted ");
      continue;

    case 'f': /* @safe */
      Mangled++;
      Decl->append("@safe ");
      continue;

    case 'g':
    case 'h':
    case 'k':
    case 'n':
      /* inout parameter is represented as 'Ng'.
         vector parameter is represented as 'Nh'.
         return parameter is represented as 'Nk'.
         typeof(*null) parameter is represented as 'Nn'.
         If we see this, then we know we're really in the
         parameter list.  Rewind and break.  */
      Mangled--;
      break;

    case 'i': /* @nogc */
      Mangled++;
      Decl->append("@nogc ");
      continue;

    case 'j': /* return */
      Mangled++;
      Decl->append("return ");
      continue;

    case 'l': /* scope */
      Mangled++;
      Decl->append("scope ");
      continue;

    case 'm': /* @live */
      Mangled++;
      Decl->append("@live ");
      continue;

    default: /* unknown attribute */
      return nullptr;
    }
    break;
  }

  return Mangled;
}

const char *Demangler::parseFunctionTypeNoreturn(OutputString *Args,
                                                 OutputString *Call,
                                                 OutputString *Attr,
                                                 const char *Mangled) {
  OutputString Dump = OutputString();
  // Skip over calling convention and attributes
  Mangled = parseCallConvention(Call ? Call : &Dump, Mangled);
  Mangled = parseAttributes(Attr ? Attr : &Dump, Mangled);

  if (Args)
    Args->append("(");

  Mangled = parseFunctionArgs(Args ? Args : &Dump, Mangled);
  if (Args)
    Args->append(")");

  Dump.free();
  return Mangled;
}

const char *Demangler::parseFunctionType(OutputString *Decl,
                                         const char *Mangled) {
  OutputString Attr, Args, Type;

  if (Mangled == nullptr || *Mangled == '\0')
    return nullptr;

  /* The order of the mangled string is:
        CallConvention FuncAttrs Arguments ArgClose Type
     The demangled string is re-ordered as:
        CallConvention Type Arguments FuncAttrs
   */
  Attr = OutputString();
  Args = OutputString();
  Type = OutputString();

  Mangled = parseFunctionTypeNoreturn(&Args, Decl, &Attr, Mangled);

  // Function return type
  Mangled = parseType(&Type, Mangled);

  // Append to decl in order
  Decl->append(Type.Buffer, Type.getLength());
  Decl->append(Args.Buffer, Args.getLength());
  Decl->append(" ");
  Decl->append(Attr.Buffer, Attr.getLength());

  Attr.free();
  Args.free();
  Type.free();
  return Mangled;
}

const char *Demangler::parseFunctionArgs(OutputString *Decl,
                                         const char *Mangled) {
  size_t N = 0;

  while (Mangled && *Mangled != '\0') {
    switch (*Mangled) {
    case 'X': /* (variadic T t...) style */
      Mangled++;
      Decl->append("...");
      return Mangled;
    case 'Y': /* (variadic T t, ...) style */
      Mangled++;
      if (N != 0)
        Decl->append(", ");
      Decl->append("...");
      return Mangled;
    case 'Z': /* Normal function */
      Mangled++;
      return Mangled;
    }

    if (N++)
      Decl->append(", ");

    if (*Mangled == 'M') /* scope(T) */
    {
      Mangled++;
      Decl->append("scope ");
    }

    if (Mangled[0] == 'N' && Mangled[1] == 'k') /* return(T) */
    {
      Mangled += 2;
      Decl->append("return ");
    }

    switch (*Mangled) {
    case 'I': /* in(T) */
      Mangled++;
      Decl->append("in ");
      if (*Mangled == 'K') /* in ref(T) */
      {
        Mangled++;
        Decl->append("ref ");
      }
      break;
    case 'J': /* out(T) */
      Mangled++;
      Decl->append("out ");
      break;
    case 'K': /* ref(T) */
      Mangled++;
      Decl->append("ref ");
      break;
    case 'L': /* lazy(T) */
      Mangled++;
      Decl->append("lazy ");
      break;
    }
    Mangled = parseType(Decl, Mangled);
  }

  return Mangled;
}

const char *Demangler::parseType(OutputString *Decl, const char *Mangled) {
  if (Mangled == nullptr || *Mangled == '\0')
    return nullptr;

  switch (*Mangled) {
  case 'O': /* shared(T) */
    Mangled++;
    Decl->append("shared(");
    Mangled = parseType(Decl, Mangled);
    Decl->append(")");
    return Mangled;

  case 'x': /* const(T) */
    Mangled++;
    Decl->append("const(");
    Mangled = parseType(Decl, Mangled);
    Decl->append(")");
    return Mangled;

  case 'y': /* immutable(T) */
    Mangled++;
    Decl->append("immutable(");
    Mangled = parseType(Decl, Mangled);
    Decl->append(")");
    return Mangled;

  case 'N':
    Mangled++;

    switch (*Mangled) {
    case 'g': // wild(T)
      Mangled++;
      Decl->append("inout(");
      Mangled = parseType(Decl, Mangled);
      Decl->append(")");
      return Mangled;

    case 'h': // vector(T)
      Mangled++;
      Decl->append("__vector(");
      Mangled = parseType(Decl, Mangled);
      Decl->append(")");
      return Mangled;

    case 'n': // typeof(*null)
      Mangled++;
      Decl->append("typeof(*null)");
      return Mangled;
    }

    // invalid
    return nullptr;

  case 'A': /* dynamic array (T[]) */
    Mangled++;
    Mangled = parseType(Decl, Mangled);
    Decl->append("[]");
    return Mangled;

  case 'G': /* static array (T[N]) */
  {
    const char *NumPtr;
    size_t Num = 0;
    Mangled++;

    NumPtr = Mangled;
    while (std::isdigit(*Mangled)) {
      Num++;
      Mangled++;
    }
    Mangled = parseType(Decl, Mangled);
    Decl->append("[");
    Decl->append(NumPtr, Num);
    Decl->append("]");
    return Mangled;
  }

  case 'H': /* associative array (T[T]) */
  {
    OutputString Type = OutputString();
    size_t Sztype;
    Mangled++;

    Mangled = parseType(&Type, Mangled);
    Sztype = Type.getLength();

    Mangled = parseType(Decl, Mangled);
    Decl->append("[");
    Decl->append(Type.Buffer, Sztype);
    Decl->append("]");

    Type.free();
    return Mangled;
  }

  case 'P': /* pointer (T*) */
    Mangled++;
    if (!isCallConvention(Mangled)) {
      Mangled = parseType(Decl, Mangled);
      Decl->append("*");
      return Mangled;
    }

    [[clang::fallthrough]];
  case 'F': /* function T (D) */
  case 'U': /* function T (C) */
  case 'W': /* function T (Windows) */
  case 'V': /* function T (Pascal) */
  case 'R': /* function T (C++) */
  case 'Y': /* function T (Objective-C) */
    /* Function pointer types don't include the trailing asterisk.  */
    Mangled = parseFunctionType(Decl, Mangled);
    Decl->append("function");
    return Mangled;

  case 'C': /* class T */
  case 'S': /* struct T */
  case 'E': /* enum T */
  case 'T': /* typedef T */
    Mangled++;
    return parseQualified(Decl, Mangled, false);

  case 'D': /* delegate T */
  {
    OutputString Mods = OutputString();
    size_t Szmods;
    Mangled++;

    Mangled = parseTypeModifiers(&Mods, Mangled);
    Szmods = Mods.getLength();

    // Back referenced function type
    if (Mangled && *Mangled == 'Q')
      Mangled = parseTypeBackref(Decl, Mangled, true);
    else
      Mangled = parseFunctionType(Decl, Mangled);

    Decl->append("delegate");
    Decl->append(Mods.Buffer, Szmods);

    Mods.free();
    return Mangled;
  }

  case 'B': /* tuple T */
    Mangled++;
    return parseTuple(Decl, Mangled);

  /* Basic types */
  case 'n':
    Mangled++;
    Decl->append("typeof(null)");
    return Mangled;

  case 'v':
    Mangled++;
    Decl->append("void");
    return Mangled;

  case 'g':
    Mangled++;
    Decl->append("byte");
    return Mangled;
  case 'h':
    Mangled++;
    Decl->append("ubyte");
    return Mangled;

  case 's':
    Mangled++;
    Decl->append("short");
    return Mangled;
  case 't':
    Mangled++;
    Decl->append("ushort");
    return Mangled;

  case 'i':
    Mangled++;
    Decl->append("int");
    return Mangled;
  case 'k':
    Mangled++;
    Decl->append("uint");
    return Mangled;

  case 'l':
    Mangled++;
    Decl->append("long");
    return Mangled;
  case 'm':
    Mangled++;
    Decl->append("ulong");
    return Mangled;

  case 'f':
    Mangled++;
    Decl->append("float");
    return Mangled;
  case 'd':
    Mangled++;
    Decl->append("double");
    return Mangled;
  case 'e':
    Mangled++;
    Decl->append("real");
    return Mangled;

  // Imaginary types
  case 'o':
    Mangled++;
    Decl->append("ifloat");
    return Mangled;
  case 'p':
    Mangled++;
    Decl->append("idouble");
    return Mangled;
  case 'j':
    Mangled++;
    Decl->append("ireal");
    return Mangled;

  // Complex types
  case 'q':
    Mangled++;
    Decl->append("cfloat");
    return Mangled;
  case 'r':
    Mangled++;
    Decl->append("cdouble");
    return Mangled;
  case 'c':
    Mangled++;
    Decl->append("creal");
    return Mangled;

  // Other types
  case 'b':
    Mangled++;
    Decl->append("bool");
    return Mangled;

  case 'a':
    Mangled++;
    Decl->append("char");
    return Mangled;
  case 'u':
    Mangled++;
    Decl->append("wchar");
    return Mangled;
  case 'w':
    Mangled++;
    Decl->append("dchar");
    return Mangled;

  case 'z':
    Mangled++;

    switch (*Mangled) {
    case 'i':
      Mangled++;
      Decl->append("cent");
      return Mangled;
    case 'k':
      Mangled++;
      Decl->append("ucent");
      return Mangled;
    }
    return nullptr;

  // Back referenced type
  case 'Q':
    return parseTypeBackref(Decl, Mangled, false);

  default: // unhandled
    return nullptr;
  }
}

const char *Demangler::parseIdentifier(OutputString *Decl,
                                       const char *Mangled) {
  unsigned long Len;

  if (Mangled == nullptr || *Mangled == '\0')
    return nullptr;

  if (*Mangled == 'Q')
    return parseSymbolBackref(Decl, Mangled);

  /* May be a template instance without a length prefix.  */
  if (Mangled[0] == '_' && Mangled[1] == '_' &&
      (Mangled[2] == 'T' || Mangled[2] == 'U'))
    return parseTemplate(Decl, Mangled);

  const char *Endptr = decodeNumber(Mangled, &Len);

  if (Endptr == nullptr || Len == 0)
    return nullptr;

  if (strlen(Endptr) < Len)
    return nullptr;

  Mangled = Endptr;

  /* May be a template instance with a length prefix.  */
  if (Len >= 5 && Mangled[0] == '_' && Mangled[1] == '_' &&
      (Mangled[2] == 'T' || Mangled[2] == 'U'))
    return parseTemplate(Decl, Mangled, Len);

  /* There can be multiple different declarations in the same function that have
     the same mangled name.  To make the mangled names unique, a fake parent in
     the form `__Sddd' is added to the symbol.  */
  if (Len >= 4 && Mangled[0] == '_' && Mangled[1] == '_' && Mangled[2] == 'S') {
    const char *NumPtr = Mangled + 3;
    while (NumPtr < (Mangled + Len) && std::isdigit(*NumPtr))
      NumPtr++;

    if (Mangled + Len == NumPtr) {
      /* Skip over the fake parent.  */
      Mangled += Len;
      return parseIdentifier(Decl, Mangled);
    }

    /* else demangle it as a plain identifier.  */
  }

  return parseLName(Decl, Mangled, Len);
}

const char *Demangler::parseLName(OutputString *Decl, const char *Mangled,
                                  unsigned long Len) {
  switch (Len) {
  case 6:
    if (strncmp(Mangled, "__ctor", Len) == 0) {
      /* Constructor symbol for a class/struct.  */
      Decl->append("this");
      Mangled += Len;
      return Mangled;
    } else if (strncmp(Mangled, "__dtor", Len) == 0) {
      /* Destructor symbol for a class/struct.  */
      Decl->append("~this");
      Mangled += Len;
      return Mangled;
    } else if (strncmp(Mangled, "__initZ", Len + 1) == 0) {
      /* The static initialiser for a given symbol.  */
      Decl->prepend("initializer for ");
      Decl->setLength(Decl->getLength() - 1);
      Mangled += Len;
      return Mangled;
    } else if (strncmp(Mangled, "__vtblZ", Len + 1) == 0) {
      /* The vtable symbol for a given class.  */
      Decl->prepend("vtable for ");
      Decl->setLength(Decl->getLength() - 1);
      Mangled += Len;
      return Mangled;
    }
    break;

  case 7:
    if (strncmp(Mangled, "__ClassZ", Len + 1) == 0) {
      /* The classinfo symbol for a given class.  */
      Decl->prepend("ClassInfo for ");
      Decl->setLength(Decl->getLength() - 1);
      Mangled += Len;
      return Mangled;
    }
    break;

  case 10:
    if (strncmp(Mangled, "__postblitMFZ", Len + 3) == 0) {
      /* Postblit symbol for a struct.  */
      Decl->append("this(this)");
      Mangled += Len + 3;
      return Mangled;
    }
    break;

  case 11:
    if (strncmp(Mangled, "__InterfaceZ", Len + 1) == 0) {
      /* The interface symbol for a given class.  */
      Decl->prepend("Interface for ");
      Decl->setLength(Decl->getLength() - 1);
      Mangled += Len;
      return Mangled;
    }
    break;

  case 12:
    if (strncmp(Mangled, "__ModuleInfoZ", Len + 1) == 0) {
      /* The ModuleInfo symbol for a given module.  */
      Decl->prepend("ModuleInfo for ");
      Decl->setLength(Decl->getLength() - 1);
      Mangled += Len;
      return Mangled;
    }
    break;
  }

  Decl->append(Mangled, Len);
  Mangled += Len;

  return Mangled;
}

const char *Demangler::parseInteger(OutputString *Decl, const char *Mangled,
                                    char Type) {
  if (Type == 'a' || Type == 'u' || Type == 'w') {
    /* Parse character value.  */
    char Value[20];
    int Pos = sizeof(Value);
    int Width = 0;
    unsigned long Val;

    Mangled = decodeNumber(Mangled, &Val);
    if (Mangled == nullptr)
      return nullptr;

    Decl->append('\'');

    if (Type == 'a' && Val >= 0x20 && Val < 0x7F) {
      /* Represent as a character literal.  */
      Decl->append(static_cast<char>(Val));
    } else {
      /* Represent as a hexadecimal value. */
      switch (Type) {
      case 'a': /* char */
        Decl->append("\\x");
        Width = 2;
        break;
      case 'u': /* wchar */
        Decl->append("\\u");
        Width = 4;
        break;
      case 'w': /* dchar */
        Decl->append("\\U");
        Width = 8;
        break;
      }

      while (Val > 0) {
        int Digit = Val % 16;

        if (Digit < 10)
          Value[--Pos] = (char)(Digit + '0');
        else
          Value[--Pos] = (char)((Digit - 10) + 'a');

        Val /= 16;
        Width--;
      }

      for (; Width > 0; Width--)
        Value[--Pos] = '0';

      Decl->append(&(Value[Pos]), sizeof(Value) - Pos);
    }
    Decl->append('\'');
  } else if (Type == 'b') {
    /* Parse boolean value.  */
    unsigned long Val;

    Mangled = decodeNumber(Mangled, &Val);
    if (Mangled == nullptr)
      return nullptr;

    Decl->append(Val ? "true" : "false");
  } else {
    /* Parse integer value.  */
    const char *NumPtr = Mangled;
    size_t Num = 0;

    if (!std::isdigit(*Mangled))
      return nullptr;

    while (std::isdigit(*Mangled)) {
      Num++;
      Mangled++;
    }
    Decl->append(NumPtr, Num);

    /* Append suffix.  */
    switch (Type) {
    case 'h': /* ubyte */
    case 't': /* ushort */
    case 'k': /* uint */
      Decl->append('u');
      break;
    case 'l': /* long */
      Decl->append('L');
      break;
    case 'm': /* ulong */
      Decl->append("uL");
      break;
    }
  }

  return Mangled;
}

const char *Demangler::parseReal(OutputString *Decl, const char *Mangled) {
  // Handle NAN and +-INF
  if (strncmp(Mangled, "NAN", 3) == 0) {
    Decl->append("NaN");
    Mangled += 3;
    return Mangled;
  }

  if (strncmp(Mangled, "INF", 3) == 0) {
    Decl->append("Inf");
    Mangled += 3;
    return Mangled;
  }

  if (strncmp(Mangled, "NINF", 4) == 0) {
    Decl->append("-Inf");
    Mangled += 4;
    return Mangled;
  }

  // Hexadecimal prefix and leading bit
  if (*Mangled == 'N') {
    Decl->append('-');
    Mangled++;
  }

  if (!std::isxdigit(*Mangled))
    return nullptr;

  Decl->append("0x");
  Decl->append(Mangled, 1);
  Decl->append('.');
  Mangled++;

  // Significand
  while (std::isxdigit(*Mangled)) {
    Decl->append(Mangled, 1);
    Mangled++;
  }

  // Exponent
  if (*Mangled != 'P')
    return nullptr;

  Decl->append('p');
  Mangled++;

  if (*Mangled == 'N') {
    Decl->append('-');
    Mangled++;
  }

  while (std::isdigit(*Mangled)) {
    Decl->append(Mangled, 1);
    Mangled++;
  }

  return Mangled;
}

const char *Demangler::parseString(OutputString *Decl, const char *Mangled) {
  char Type = *Mangled;
  unsigned long Len;

  Mangled++;
  Mangled = decodeNumber(Mangled, &Len);
  if (Mangled == nullptr || *Mangled != '_')
    return nullptr;

  Mangled++;
  Decl->append('\"');
  while (Len--) {
    char Val;
    const char *Endptr = decodeHexdigit(Mangled, &Val);

    if (Endptr == nullptr)
      return nullptr;

    /* Sanitize white and non-printable characters.  */
    switch (Val) {
    case ' ':
      Decl->append(' ');
      break;
    case '\t':
      Decl->append("\\t");
      break;
    case '\n':
      Decl->append("\\n");
      break;
    case '\r':
      Decl->append("\\r");
      break;
    case '\f':
      Decl->append("\\f");
      break;
    case '\v':
      Decl->append("\\v");
      break;

    default:
      if (std::isprint(Val))
        Decl->append(Val);
      else {
        Decl->append("\\x");
        Decl->append(Mangled, 2);
      }
    }

    Mangled = Endptr;
  }
  Decl->append('\"');

  if (Type != 'a')
    Decl->append(Type);

  return Mangled;
}

const char *Demangler::parseArrayLiteral(OutputString *Decl,
                                         const char *Mangled) {
  unsigned long Elements;

  Mangled = decodeNumber(Mangled, &Elements);
  if (Mangled == nullptr)
    return nullptr;

  Decl->append('[');
  while (Elements--) {
    Mangled = parseValue(Decl, Mangled, nullptr, '\0');
    if (Mangled == nullptr)
      return nullptr;

    if (Elements != 0)
      Decl->append(", ");
  }

  Decl->append(']');
  return Mangled;
}

const char *Demangler::parseAssocArray(OutputString *Decl,
                                       const char *Mangled) {
  unsigned long Elements;

  Mangled = decodeNumber(Mangled, &Elements);
  if (Mangled == nullptr)
    return nullptr;

  Decl->append('[');
  while (Elements--) {
    Mangled = parseValue(Decl, Mangled, nullptr, '\0');
    if (Mangled == nullptr)
      return nullptr;

    Decl->append(':');
    Mangled = parseValue(Decl, Mangled, nullptr, '\0');
    if (Mangled == nullptr)
      return nullptr;

    if (Elements != 0)
      Decl->append(", ");
  }

  Decl->append(']');
  return Mangled;
}

const char *Demangler::parseStructLiteral(OutputString *Decl,
                                          const char *Mangled,
                                          const char *Name) {
  unsigned long Args;

  Mangled = decodeNumber(Mangled, &Args);
  if (Mangled == nullptr)
    return nullptr;

  if (Name != nullptr)
    Decl->append(Name);

  Decl->append('(');
  while (Args--) {
    Mangled = parseValue(Decl, Mangled, nullptr, '\0');
    if (Mangled == nullptr)
      return nullptr;

    if (Args != 0)
      Decl->append(", ");
  }

  Decl->append(')');
  return Mangled;
}

const char *Demangler::parseValue(OutputString *Decl, const char *Mangled,
                                  const char *Name, char Type) {
  if (Mangled == nullptr || *Mangled == '\0')
    return nullptr;

  switch (*Mangled) {
    /* Null value.  */
  case 'n':
    Mangled++;
    Decl->append("null");
    break;

    /* Integral values.  */
  case 'N':
    Mangled++;
    Decl->append('-');
    Mangled = parseInteger(Decl, Mangled, Type);
    break;

  case 'i':
    Mangled++;
    /* Fall through */

    /* There really should always be an `i' before encoded numbers, but there
       wasn't in early versions of D2, so this case range must remain for
       backwards compatibility.  */
    [[clang::fallthrough]];
  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
    Mangled = parseInteger(Decl, Mangled, Type);
    break;

    /* Real value.  */
  case 'e':
    Mangled++;
    Mangled = parseReal(Decl, Mangled);
    break;

    /* Complex value.  */
  case 'c':
    Mangled++;
    Mangled = parseReal(Decl, Mangled);
    Decl->append('+');
    if (Mangled == nullptr || *Mangled != 'c')
      return nullptr;
    Mangled++;
    Mangled = parseReal(Decl, Mangled);
    Decl->append('i');
    break;

    /* String values.  */
  case 'a': /* UTF8 */
  case 'w': /* UTF16 */
  case 'd': /* UTF32 */
    Mangled = parseString(Decl, Mangled);
    break;

    /* Array values.  */
  case 'A':
    Mangled++;
    if (Type == 'H')
      Mangled = parseAssocArray(Decl, Mangled);
    else
      Mangled = parseArrayLiteral(Decl, Mangled);
    break;

    /* Struct values.  */
  case 'S':
    Mangled++;
    Mangled = parseStructLiteral(Decl, Mangled, Name);
    break;

    /* Function literal symbol.  */
  case 'f':
    Mangled++;
    if (strncmp(Mangled, "_D", 2) != 0 || !isSymbolName(Mangled + 2))
      return nullptr;
    Mangled = parseMangle(Decl, Mangled);
    break;

  default:
    return nullptr;
  }

  return Mangled;
}

const char *Demangler::parseMangle(OutputString *Decl, const char *Mangled) {
  /* A D mangled symbol is comprised of both scope and type information.
        MangleName:
            _D QualifiedName Type
            _D QualifiedName Z
            ^
     The caller should have guaranteed that the start pointer is at the
     above location.
     Note that type is never a function type, but only the return type of
     a function or the type of a variable.
   */
  Mangled += 2;

  Mangled = parseQualified(Decl, Mangled, true);

  if (Mangled != nullptr) {
    /* Artificial symbols end with 'Z' and have no type.  */
    if (*Mangled == 'Z')
      Mangled++;
    else {
      /* Discard the declaration or return type.  */
      OutputString Type = OutputString();

      Mangled = parseType(&Type, Mangled);
      Type.free();
    }
  }

  return Mangled;
}

const char *Demangler::parseQualified(OutputString *Decl, const char *Mangled,
                                      bool SuffixModifiers) {
  /* Qualified names are identifiers separated by their encoded length.
     Nested functions also encode their argument types without specifying
     what they return.
        QualifiedName:
            SymbolFunctionName
            SymbolFunctionName QualifiedName
            ^
        SymbolFunctionName:
            SymbolName
            SymbolName TypeFunctionNoReturn
            SymbolName M TypeFunctionNoReturn
            SymbolName M TypeModifiers TypeFunctionNoReturn
     The start pointer should be at the above location.
   */
  size_t N = 0;
  do {
    if (N++)
      Decl->append('.');

    /* Skip over anonymous symbols.  */
    while (*Mangled == '0')
      Mangled++;

    Mangled = parseIdentifier(Decl, Mangled);

    /* Consume the encoded arguments.  However if this is not followed by the
       next encoded length or mangle type, then this is not a continuation of
       a qualified name, in which case we backtrack and return the current
       unconsumed position of the mangled decl.  */
    if (Mangled && (*Mangled == 'M' || isCallConvention(Mangled))) {
      const char *Start = Mangled;
      int Saved = Decl->getLength();

      /* Save the type modifiers for appending at the end if needed. */
      OutputString Mods = OutputString();

      /* Skip over 'this' parameter and type modifiers.  */
      if (*Mangled == 'M') {
        Mangled++;
        Mangled = parseTypeModifiers(&Mods, Mangled);
        Decl->setLength(Saved);
      }

      Mangled = parseFunctionTypeNoreturn(Decl, nullptr, nullptr, Mangled);
      if (SuffixModifiers)
        Decl->append(Mods.Buffer, Mods.getLength());

      if (Mangled == nullptr || *Mangled == '\0') {
        /* Did not match the rule we were looking for.  */
        Mangled = Start;
        Decl->setLength(Saved);
      }

      Mods.free();
    }
  } while (Mangled && isSymbolName(Mangled));

  return Mangled;
}

const char *Demangler::parseTuple(OutputString *Decl, const char *Mangled) {
  unsigned long Elements;

  Mangled = decodeNumber(Mangled, &Elements);
  if (Mangled == nullptr)
    return nullptr;

  Decl->append("Tuple!(");

  while (Elements--) {
    Mangled = parseType(Decl, Mangled);
    if (Mangled == nullptr)
      return nullptr;

    if (Elements != 0)
      Decl->append(", ");
  }

  Decl->append(')');
  return Mangled;
}

const char *Demangler::parseTemplateSymbolParameter(OutputString *Decl,
                                                    const char *Mangled) {
  if (strncmp(Mangled, "_D", 2) == 0 && isSymbolName(Mangled + 2))
    return parseMangle(Decl, Mangled);

  if (*Mangled == 'Q')
    return parseQualified(Decl, Mangled, false);

  unsigned long Len;
  const char *EndPtr = decodeNumber(Mangled, &Len);

  if (EndPtr == nullptr || Len == 0)
    return nullptr;

  /* In template parameter symbols generated by the frontend up to 2.076,
     the symbol length is encoded and the first character of the mangled
     name can be a digit.  This causes ambiguity issues because the digits
     of the two numbers are adjacent.  */
  long PtrSize = Len;
  const char *PtrEnd;
  int Saved = Decl->getLength();

  /* Work backwards until a match is found.  */
  for (PtrEnd = EndPtr; EndPtr != nullptr; PtrEnd--) {
    Mangled = PtrEnd;

    /* Reached the beginning of the pointer to the name length,
       try parsing the entire symbol.  */
    if (PtrSize == 0) {
      PtrSize = Len;
      PtrEnd = EndPtr;
      EndPtr = nullptr;
    }

    /* Check whether template parameter is a function with a valid
       return type or an untyped identifier.  */
    if (isSymbolName(Mangled))
      Mangled = parseQualified(Decl, Mangled, false);
    else if (strncmp(Mangled, "_D", 2) == 0 && isSymbolName(Mangled + 2))
      Mangled = parseMangle(Decl, Mangled);

    /* Check for name length mismatch.  */
    if (Mangled && (EndPtr == nullptr || (Mangled - PtrEnd) == PtrSize))
      return Mangled;

    PtrSize /= 10;
    Decl->setLength(Saved);
  }

  /* No match on any combinations.  */
  return nullptr;
}

const char *Demangler::parseTemplateArgs(OutputString *Decl,
                                         const char *Mangled) {
  size_t N = 0;

  while (Mangled && *Mangled != '\0') {
    switch (*Mangled) {
    case 'Z': /* End of parameter list.  */
      Mangled++;
      return Mangled;
    }

    if (N++)
      Decl->append(", ");

    /* Skip over specialised template prefix.  */
    if (*Mangled == 'H')
      Mangled++;

    switch (*Mangled) {
    case 'S': /* Symbol parameter.  */
      Mangled++;
      Mangled = parseTemplateSymbolParameter(Decl, Mangled);
      break;
    case 'T': /* Type parameter.  */
      Mangled++;
      Mangled = parseType(Decl, Mangled);
      break;
    case 'V': /* Value parameter. */
    {
      OutputString Name;
      char Type;

      /* Peek at the type.  */
      Mangled++;
      Type = *Mangled;

      if (Type == 'Q') {
        /* Value type is a back reference, peek at the real type.  */
        const char *Backref;
        if (decodeBackref(Mangled, &Backref) == nullptr)
          return nullptr;

        Type = *Backref;
      }

      /* In the few instances where the type is actually desired in
         the output, it should precede the value from dlang_value.  */
      Name = OutputString();
      Mangled = parseType(&Name, Mangled);
      Name.append('\0');
      Name.Ptr--;

      Mangled = parseValue(Decl, Mangled, Name.Buffer, Type);
      Name.free();
      break;
    }
    case 'X': /* Externally mangled parameter.  */
    {
      unsigned long Len;
      const char *EndPtr;

      Mangled++;
      EndPtr = decodeNumber(Mangled, &Len);
      if (EndPtr == nullptr || strlen(EndPtr) < Len)
        return nullptr;

      Decl->append(EndPtr, Len);
      Mangled = EndPtr + Len;
      break;
    }
    default:
      return nullptr;
    }
  }

  return Mangled;
}

const char *Demangler::parseTemplate(OutputString *Decl, const char *Mangled,
                                     unsigned long Len) {
  const char *Start = Mangled;
  OutputString Args;

  /* Template instance names have the types and values of its parameters
     encoded into it.
        TemplateInstanceName:
            Number __T LName TemplateArgs Z
            Number __U LName TemplateArgs Z
                   ^
     The start pointer should be at the above location, and LEN should be
     the value of the decoded number.
   */

  /* Template symbol. */
  if (!isSymbolName(Mangled + 3) || Mangled[3] == '0')
    return nullptr;

  Mangled += 3;

  /* Template identifier. */
  Mangled = parseIdentifier(Decl, Mangled);

  /* Template arguments. */
  Args = OutputString();
  Mangled = parseTemplateArgs(&Args, Mangled);

  Decl->append("!(");
  Decl->append(Args.Buffer, Args.getLength());
  Decl->append(')');

  Args.free();

  /* Check for template name length mismatch.  */
  if (Len != -1UL && Mangled && (unsigned long)(Mangled - Start) != Len)
    return nullptr;

  return Mangled;
}

Demangler::Demangler(const char *Mangled)
    : Str(Mangled), LastBackref(strlen(Mangled)) {}

const char *Demangler::parseMangle(OutputString *Decl) {
  return parseMangle(Decl, this->Str);
}

char *llvm::dlangDemangle(const char *MangledName) {
  OutputString Decl;
  char *Demangled = nullptr;

  if (MangledName == nullptr || *MangledName == '\0')
    return nullptr;

  if (strncmp(MangledName, "_D", 2) != 0)
    return nullptr;

  Decl = OutputString();

  if (strcmp(MangledName, "_Dmain") == 0) {
    Decl.append("D main");
  } else {

    Demangler D = Demangler(MangledName);
    MangledName = D.parseMangle(&Decl);

    /* Check that the entire symbol was successfully demangled.  */
    if (MangledName == nullptr || *MangledName != '\0')
      Decl.free();
  }

  if (Decl.getLength() > 0) {
    Decl.append('\0');
    Decl.Ptr--;
    Demangled = Decl.Buffer;
  }

  return Demangled;
}

/* vim: set ts=2 sw=2 expandtab */
